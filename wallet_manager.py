"""
TON Wallet Address Management System
Handles wallet address collection and storage for different scenarios
"""

import asyncio
import logging
from typing import Optional, Dict, Any
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from states import WalletStates, AdCreationStates
from database import db
from languages import get_text
from database import get_user_language
from fix_ui_issues import create_wallet_button_text


logger = logging.getLogger(__name__)
router = Router()

class WalletManager:
    """Centralized TON wallet address management"""
    
    @staticmethod
    def validate_ton_address(address: str) -> bool:
        """Validate TON wallet address format"""
        if not address:
            return False
        
        # Remove whitespace
        address = address.strip()
        
        # Check prefix and length
        if not (address.startswith('EQ') or address.startswith('UQ')):
            return False
        
        if len(address) != 48:
            return False
        
        # Check if it's alphanumeric + allowed characters
        allowed_chars = set('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_')
        if not all(c in allowed_chars for c in address):
            return False
        
        return True
    
    @staticmethod
    async def get_user_wallet_address(user_id: int) -> Optional[str]:
        """Get user's stored TON wallet address"""
        try:
            user = await db.get_user(user_id)
            if user:
                return user.get('ton_wallet_address')
            return None
        except Exception as e:
            logger.error(f"Error getting user wallet address: {e}")
            return None
    
    @staticmethod
    async def set_user_wallet_address(user_id: int, wallet_address: str) -> bool:
        """Store user's TON wallet address"""
        try:
            await db.set_user_wallet_address(user_id, wallet_address)
            return True
        except Exception as e:
            logger.error(f"Error setting user wallet address: {e}")
            return False
    
    @staticmethod
    async def request_wallet_address(message_or_callback, state: FSMContext, context: str = 'payment'):
        """Request TON wallet address from user based on context"""
        # Handle both Message and CallbackQuery types
        if hasattr(message_or_callback, 'from_user'):
            user_id = message_or_callback.from_user.id
            if hasattr(message_or_callback, 'message'):
                # CallbackQuery
                send_method = message_or_callback.message.edit_text
            else:
                # Message
                send_method = message_or_callback.reply
        else:
            return
        
        language = await get_user_language(user_id)
        
        # Check if user already has a wallet address
        existing_wallet = await WalletManager.get_user_wallet_address(user_id)
        
        if existing_wallet:
            # User has existing wallet, ask if they want to use it or enter new one
            await WalletManager.show_wallet_options(message_or_callback, state, existing_wallet, context)
            return
        
        # No existing wallet, request new one
        await WalletManager.show_wallet_input_prompt(message_or_callback, state, context)
    
    @staticmethod
    async def show_wallet_options(message_or_callback, state: FSMContext, existing_wallet: str, context: str):
        """Show options to use existing wallet or enter new one"""
        user_id = message_or_callback.from_user.id
        language = await get_user_language(user_id)
        
        # Create context-specific messages
        if context == 'payment':
            if language == 'ar':
                title = "üí∞ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿØŸÅÿπ"
                description = "ŸÑÿØŸäŸÉ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`{wallet_display}`"
                enter_new = "üîÑ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≠ŸÅÿ∏ÿ© ÿ¨ÿØŸäÿØÿ©"
            elif language == 'ru':
                title = "üí∞ TON –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã"
                description = "–£ –≤–∞—Å –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π TON –∫–æ—à–µ–ª–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫\n`{wallet_display}`"
                enter_new = "üîÑ –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫"
            else:
                title = "üí∞ TON Wallet Address for Payment"
                description = "You have a saved TON wallet. Choose an option:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ Use Current Wallet\n`{wallet_display}`"
                enter_new = "üîÑ Enter New Wallet"
        
        elif context == 'affiliate':
            if language == 'ar':
                title = "ü§ù ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπ"
                description = "ŸÑÿØŸäŸÉ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`{wallet_display}`"
                enter_new = "üîÑ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≠ŸÅÿ∏ÿ© ÿ¨ÿØŸäÿØÿ©"
            elif language == 'ru':
                title = "ü§ù TON –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã"
                description = "–£ –≤–∞—Å –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π TON –∫–æ—à–µ–ª–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫\n`{wallet_display}`"
                enter_new = "üîÑ –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫"
            else:
                title = "ü§ù TON Wallet Address for Affiliate Program"
                description = "You have a saved TON wallet. Choose an option:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ Use Current Wallet\n`{wallet_display}`"
                enter_new = "üîÑ Enter New Wallet"
        
        elif context == 'channel':
            if language == 'ar':
                title = "üì∫ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ©"
                description = "ŸÑÿØŸäŸÉ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`{wallet_display}`"
                enter_new = "üîÑ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≠ŸÅÿ∏ÿ© ÿ¨ÿØŸäÿØÿ©"
            elif language == 'ru':
                title = "üì∫ TON –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞"
                description = "–£ –≤–∞—Å –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π TON –∫–æ—à–µ–ª–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫\n`{wallet_display}`"
                enter_new = "üîÑ –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫"
            else:
                title = "üì∫ TON Wallet Address for Channel Addition"
                description = "You have a saved TON wallet. Choose an option:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ Use Current Wallet\n`{wallet_display}`"
                enter_new = "üîÑ Enter New Wallet"
        
        text = f"**{title}**\n\n{description}"
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=use_existing, callback_data=f"use_existing_wallet_{context}")],
            [InlineKeyboardButton(text=enter_new, callback_data=f"enter_new_wallet_{context}")],
            [InlineKeyboardButton(text="‚ùå Cancel" if language == 'en' else "‚ùå ÿ•ŸÑÿ∫ÿßÿ°" if language == 'ar' else "‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_wallet_input")]
        ])
        
        # Store context and existing wallet for later use
        await state.update_data(
            wallet_context=context,
            existing_wallet=existing_wallet
        )
        
        if hasattr(message_or_callback, 'message'):
            await message_or_callback.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        else:
            await message_or_callback.reply(text, reply_markup=keyboard, parse_mode='Markdown')
    
    @staticmethod
    async def show_wallet_input_prompt(message_or_callback, state: FSMContext, context: str):
        """Show wallet input prompt based on context"""
        user_id = message_or_callback.from_user.id
        language = await get_user_language(user_id)
        
        # Create context-specific messages
        if context == 'payment':
            if language == 'ar':
                title = "üí∞ ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿØŸÅÿπ"
                description = "ŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿØŸÅÿπÿ© TONÿå ŸÜÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ:"
                instructions = """**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:**
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ Ÿáÿ∞ÿß ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ÿ≥ÿ™ÿØŸÅÿπ ŸÖŸÜŸá
- Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿ£ŸÖŸàÿßŸÑ"""
            elif language == 'ru':
                title = "üí∞ –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ TON –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã"
                description = "–î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ TON –ø–ª–∞—Ç–µ–∂–∞ –Ω–∞–º –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞:"
                instructions = """**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**
- –≠—Ç–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∞–¥—Ä–µ—Å, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã –±—É–¥–µ—Ç–µ –ø–ª–∞—Ç–∏—Ç—å
- –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å EQ –∏–ª–∏ UQ
- –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ—á–Ω–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
- –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ—Ç–µ—Ä–∏ —Å—Ä–µ–¥—Å—Ç–≤"""
            else:
                title = "üí∞ Enter TON Wallet Address for Payment"
                description = "To process your TON payment, we need your wallet address:"
                instructions = """**Instructions:**
- This should be the address you will pay from
- Starts with EQ or UQ
- Must be exactly 48 characters
- Ensure the address is correct to avoid loss of funds"""
        
        elif context == 'affiliate':
            if language == 'ar':
                title = "ü§ù ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπ"
                description = "ŸÑÿ™ŸÑŸÇŸä ÿπŸÖŸàŸÑÿßÿ™ ÿßŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπÿå ŸÜÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ:"
                instructions = """**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:**
- ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸàŸÑÿßÿ™ ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿπŸÜŸàÿßŸÜ
- Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿπŸÖŸàŸÑÿßÿ™"""
            elif language == 'ru':
                title = "ü§ù –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ TON –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã"
                description = "–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–∏—Å—Å–∏–π –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞–º –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞:"
                instructions = """**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**
- –í—Å–µ –∫–æ–º–∏—Å—Å–∏–∏ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ —ç—Ç–æ—Ç –∞–¥—Ä–µ—Å
- –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å EQ –∏–ª–∏ UQ
- –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ—á–Ω–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
- –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –∫–æ–º–∏—Å—Å–∏–∏"""
            else:
                title = "ü§ù Enter TON Wallet Address for Affiliate Program"
                description = "To receive affiliate commissions, we need your wallet address:"
                instructions = """**Instructions:**
- All commissions will be sent to this address
- Starts with EQ or UQ
- Must be exactly 48 characters
- Ensure the address is correct to avoid losing commissions"""
        
        elif context == 'channel':
            if language == 'ar':
                title = "üì∫ ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ©"
                description = "ŸÑÿ™ŸÑŸÇŸä ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©ÿå ŸÜÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ:"
                instructions = """**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:**
- ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÜÿ¥ÿ± ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿπŸÜŸàÿßŸÜ
- Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠"""
            elif language == 'ru':
                title = "üì∫ –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ TON –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞"
                description = "–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Ö–æ–¥–æ–≤ –æ—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤ –∫–∞–Ω–∞–ª–µ –Ω–∞–º –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞:"
                instructions = """**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**
- –í—Å–µ –¥–æ—Ö–æ–¥—ã –æ—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ —ç—Ç–æ—Ç –∞–¥—Ä–µ—Å
- –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å EQ –∏–ª–∏ UQ
- –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ—á–Ω–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
- –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Ö–æ–¥—ã"""
            else:
                title = "üì∫ Enter TON Wallet Address for Channel Addition"
                description = "To receive channel publishing earnings, we need your wallet address:"
                instructions = """**Instructions:**
- All publishing earnings will be sent to this address
- Starts with EQ or UQ
- Must be exactly 48 characters
- Ensure the address is correct to avoid losing earnings"""
        
        text = f"**{title}**\n\n{description}\n\n{instructions}\n\n**Example:** `EQDZpONCwPqBcWezyEGK9ikCHMknoyTrBL-L2hATQbClmrSE`\n\nüí¨ Send your wallet address now:"
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚ùå Cancel" if language == 'en' else "‚ùå ÿ•ŸÑÿ∫ÿßÿ°" if language == 'ar' else "‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_wallet_input")]
        ])
        
        # Set appropriate state based on context
        if context == 'payment':
            await state.set_state(WalletStates.payment_wallet_input)
        elif context == 'affiliate':
            await state.set_state(WalletStates.affiliate_wallet_input)
        elif context == 'channel':
            await state.set_state(WalletStates.channel_wallet_input)
        
        # Store context for later use
        await state.update_data(wallet_context=context)
        
        if hasattr(message_or_callback, 'message'):
            await message_or_callback.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        else:
            await message_or_callback.reply(text, reply_markup=keyboard, parse_mode='Markdown')

# Callback handlers for wallet options
@router.callback_query(F.data.startswith("use_existing_wallet_"))
async def use_existing_wallet_handler(callback_query: CallbackQuery, state: FSMContext):
    """Handle using existing wallet address"""
    try:
        user_id = callback_query.from_user.id
        language = await get_user_language(user_id)
        
        # Extract context from callback data
        context = callback_query.data.replace("use_existing_wallet_", "")
        
        # Get existing wallet from state data
        data = await state.get_data()
        existing_wallet = data.get('existing_wallet')
        
        # If no wallet in state, try to get from database
        if not existing_wallet:
            existing_wallet = await WalletManager.get_user_wallet_address(user_id)
        
        if not existing_wallet:
            # Show error message in user's language
            error_msg = {
                'ar': "‚ùå ÿÆÿ∑ÿ£: ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≠ŸÅÿ∏ÿ© ŸÖÿ≠ŸÅŸàÿ∏ÿ©",
                'ru': "‚ùå –û—à–∏–±–∫–∞: –ù–µ –Ω–∞–π–¥–µ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –∫–æ—à–µ–ª–µ–∫",
                'en': "‚ùå Error: No saved wallet found"
            }.get(language, "‚ùå Error: No saved wallet found")
            
            await callback_query.answer(error_msg, show_alert=True)
            return
        
        # Show loading message
        loading_msg = {
            'ar': "üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ© ÿ®ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©...",
            'ru': "üîÑ –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å —Ç–µ–∫—É—â–∏–º –∫–æ—à–µ–ª—å–∫–æ–º...",
            'en': "üîÑ Continuing with current wallet..."
        }.get(language, "üîÑ Continuing with current wallet...")
        
        await callback_query.answer(loading_msg)
        
        # Continue with the appropriate flow based on context
        if context == 'payment':
            await continue_payment_with_wallet(callback_query, state, existing_wallet)
        elif context == 'affiliate':
            await continue_affiliate_with_wallet(callback_query, state, existing_wallet)
        elif context == 'channel':
            await continue_channel_with_wallet(callback_query, state, existing_wallet)
        else:
            # Unknown context error
            error_msg = {
                'ar': "‚ùå ÿÆÿ∑ÿ£: ÿ≥ŸäÿßŸÇ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ",
                'ru': "‚ùå –û—à–∏–±–∫–∞: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç",
                'en': "‚ùå Error: Unknown context"
            }.get(language, "‚ùå Error: Unknown context")
            
            await callback_query.answer(error_msg, show_alert=True)
            
    except Exception as e:
        logger.error(f"Error in use_existing_wallet_handler: {e}")
        
        # Show generic error message
        error_msg = {
            'ar': "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ",
            'ru': "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑",
            'en': "‚ùå An error occurred, please try again"
        }.get(language, "‚ùå An error occurred, please try again")
        
        await callback_query.answer(error_msg, show_alert=True)

@router.callback_query(F.data.startswith("enter_new_wallet_"))
async def enter_new_wallet_handler(callback_query: CallbackQuery, state: FSMContext):
    """Handle entering new wallet address"""
    context = callback_query.data.replace("enter_new_wallet_", "")
    
    # Show wallet input prompt
    await WalletManager.show_wallet_input_prompt(callback_query, state, context)
    await callback_query.answer()

# Message handlers for wallet address input
@router.message(WalletStates.payment_wallet_input)
async def handle_payment_wallet_input(message: Message, state: FSMContext):
    """Handle wallet address input for payment"""
    await process_wallet_input(message, state, 'payment')

@router.message(WalletStates.affiliate_wallet_input)
async def handle_affiliate_wallet_input(message: Message, state: FSMContext):
    """Handle wallet address input for affiliate program"""
    await process_wallet_input(message, state, 'affiliate')

@router.message(WalletStates.channel_wallet_input)
async def handle_channel_wallet_input(message: Message, state: FSMContext):
    """Handle wallet address input for channel addition"""
    await process_wallet_input(message, state, 'channel')

async def process_wallet_input(message: Message, state: FSMContext, context: str):
    """Process wallet address input"""
    user_id = message.from_user.id
    language = await get_user_language(user_id)
    wallet_address = message.text.strip()
    
    # Validate wallet address
    if not WalletManager.validate_ton_address(wallet_address):
        if language == 'ar':
            error_text = "‚ùå ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠. Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ ŸàŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ:"
        elif language == 'ru':
            error_text = "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞. –î–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å EQ –∏–ª–∏ UQ –∏ –±—ã—Ç—å –¥–ª–∏–Ω–æ–π 48 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:"
        else:
            error_text = "‚ùå Invalid wallet address. Must start with EQ or UQ and be 48 characters long. Try again:"
        
        await message.reply(error_text)
        return
    
    # Store wallet address
    await WalletManager.set_user_wallet_address(user_id, wallet_address)
    
    # Continue with appropriate flow based on context
    if context == 'payment':
        await continue_payment_with_wallet(message, state, wallet_address)
    elif context == 'affiliate':
        await continue_affiliate_with_wallet(message, state, wallet_address)
    elif context == 'channel':
        await continue_channel_with_wallet(message, state, wallet_address)

async def continue_payment_with_wallet(message_or_callback, state: FSMContext, wallet_address: str):
    """Continue payment process with wallet address"""
    # Get payment amount from state
    data = await state.get_data()
    amount_ton = data.get('pending_payment_amount')
    
    if not amount_ton:
        # Handle both Message and CallbackQuery objects
        error_msg = "‚ùå Payment session expired. Please start over."
        if hasattr(message_or_callback, 'message'):
            # CallbackQuery
            await message_or_callback.message.answer(error_msg)
        else:
            # Message
            await message_or_callback.reply(error_msg)
        return
    
    # Store wallet address in state
    await state.update_data(user_wallet_address=wallet_address)
    
    # Create a simplified payment processing directly here to avoid complex object handling
    user_id = message_or_callback.from_user.id
    language = await get_user_language(user_id)
    
    # Generate payment details
    import random
    import string
    import time
    from config import TON_WALLET_ADDRESS
    
    bot_wallet = TON_WALLET_ADDRESS or "EQDZpONCwPqBcWezyEGK9ikCHMknoyTrBL-L2hATQbClmrSE"
    
    # Generate unique memo (2 letters + 4 digits format)
    letters = ''.join(random.choices(string.ascii_uppercase, k=2))
    digits = ''.join(random.choices(string.digits, k=4))
    memo = letters + digits
    
    # Create expiration timestamp (20 minutes from now)
    expiration_time = int(time.time()) + (20 * 60)
    
    # Store payment info
    await state.update_data(
        payment_memo=memo,
        payment_amount=amount_ton,
        payment_expiration=expiration_time,
        bot_wallet=bot_wallet
    )
    
    # Create concise payment message to avoid MESSAGE_TOO_LONG
    if language == 'ar':
        payment_text = f"""üí∞ **ÿØŸÅÿπ TON**

**ÿßŸÑŸÖÿ®ŸÑÿ∫:** {amount_ton:.3f} TON
**ÿßŸÑÿπŸÜŸàÿßŸÜ:** `{bot_wallet}`
**ÿßŸÑŸÖÿ∞ŸÉÿ±ÿ©:** `{memo}`

**ÿÆÿ∑Ÿàÿßÿ™:**
1. ÿßŸÅÿ™ÿ≠ ŸÖÿ≠ŸÅÿ∏ÿ© TON
2. ÿ£ÿ±ÿ≥ŸÑ {amount_ton:.3f} TON ŸÑŸÑÿπŸÜŸàÿßŸÜ
3. ÿ£ÿ∂ŸÅ ÿßŸÑŸÖÿ∞ŸÉÿ±ÿ© `{memo}`
4. ÿ£ŸÉÿØ ÿßŸÑÿØŸÅÿπ

‚è∞ 20 ÿØŸÇŸäŸÇÿ©
‚úÖ ÿ™ÿ≠ŸÇŸÇ ÿ™ŸÑŸÇÿßÿ¶Ÿä

üîí ÿ®ÿØŸÅÿπŸÉÿå ÿ™ÿ™ŸÅŸÇ ÿπŸÑŸâ ÿßŸÑÿ¥ÿ±Ÿàÿ∑"""
    elif language == 'ru':
        payment_text = f"""üí∞ **–û–ø–ª–∞—Ç–∞ TON**

**–°—É–º–º–∞:** {amount_ton:.3f} TON
**–ê–¥—Ä–µ—Å:** `{bot_wallet}`
**–ó–∞–º–µ—Ç–∫–∞:** `{memo}`

**–®–∞–≥–∏:**
1. –û—Ç–∫—Ä–æ–π—Ç–µ TON –∫–æ—à–µ–ª–µ–∫
2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ {amount_ton:.3f} TON
3. –î–æ–±–∞–≤—å—Ç–µ –∑–∞–º–µ—Ç–∫—É `{memo}`
4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ

‚è∞ 20 –º–∏–Ω—É—Ç
‚úÖ –ê–≤—Ç–æ–ø—Ä–æ–≤–µ—Ä–∫–∞

üîí –û–ø–ª–∞—á–∏–≤–∞—è, —Å–æ–≥–ª–∞—à–∞–µ—Ç–µ—Å—å"""
    else:
        payment_text = f"""üí∞ **TON Payment**

**Amount:** {amount_ton:.3f} TON
**Address:** `{bot_wallet}`
**Memo:** `{memo}`

**Steps:**
1. Open TON wallet
2. Send {amount_ton:.3f} TON
3. Add memo `{memo}`
4. Confirm payment

‚è∞ 20 minutes
‚úÖ Auto-verification

üîí By paying, you agree"""
    
    # Create cancel keyboard
    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    
    cancel_text = "‚ùå ÿ•ŸÑÿ∫ÿßÿ°" if language == 'ar' else "‚ùå –û—Ç–º–µ–Ω–∞" if language == 'ru' else "‚ùå Cancel"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text=cancel_text, callback_data="cancel_payment")]
    ])
    
    # Send payment message
    if hasattr(message_or_callback, 'message'):
        # CallbackQuery
        await message_or_callback.message.answer(payment_text, reply_markup=keyboard, parse_mode='Markdown')
    else:
        # Message
        await message_or_callback.answer(payment_text, reply_markup=keyboard, parse_mode='Markdown')
    
    # Start enhanced payment monitoring
    import asyncio
    from enhanced_ton_payment_monitoring import monitor_ton_payment_enhanced
    asyncio.create_task(monitor_ton_payment_enhanced(user_id, memo, amount_ton, expiration_time, wallet_address, state, bot_wallet))

async def continue_affiliate_with_wallet(message_or_callback, state: FSMContext, wallet_address: str):
    """Continue affiliate program enrollment with wallet address"""
    user_id = message_or_callback.from_user.id
    language = await get_user_language(user_id)
    
    # Store wallet address for affiliate program
    await state.update_data(affiliate_wallet_address=wallet_address)
    
    # Continue with affiliate enrollment
    if language == 'ar':
        success_text = f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ŸÖÿ≠ŸÅÿ∏ÿ© TON ÿ®ŸÜÿ¨ÿßÿ≠!\n\n**ÿßŸÑÿπŸÜŸàÿßŸÜ:** `{wallet_address}`\n\nü§ù ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπ Ÿàÿ™ŸÑŸÇŸä ÿßŸÑÿπŸÖŸàŸÑÿßÿ™."
    elif language == 'ru':
        success_text = f"‚úÖ TON –∫–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n**–ê–¥—Ä–µ—Å:** `{wallet_address}`\n\nü§ù –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –∏ –ø–æ–ª—É—á–∞—Ç—å –∫–æ–º–∏—Å—Å–∏–∏."
    else:
        success_text = f"‚úÖ TON wallet saved successfully!\n\n**Address:** `{wallet_address}`\n\nü§ù You can now join the affiliate program and receive commissions."
    
    # Handle both Message and CallbackQuery objects
    if hasattr(message_or_callback, 'message'):
        # CallbackQuery
        await message_or_callback.message.answer(success_text, parse_mode='Markdown')
    else:
        # Message
        await message_or_callback.reply(success_text, parse_mode='Markdown')

async def continue_channel_with_wallet(message_or_callback, state: FSMContext, wallet_address: str):
    """Continue channel addition with wallet address"""
    user_id = message_or_callback.from_user.id
    language = await get_user_language(user_id)
    
    # Store wallet address for channel earnings
    await state.update_data(channel_wallet_address=wallet_address)
    
    # Continue with channel addition
    if language == 'ar':
        success_text = f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ŸÖÿ≠ŸÅÿ∏ÿ© TON ÿ®ŸÜÿ¨ÿßÿ≠!\n\n**ÿßŸÑÿπŸÜŸàÿßŸÜ:** `{wallet_address}`\n\nüì∫ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ™ŸÉ Ÿàÿ™ŸÑŸÇŸä ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÜÿ¥ÿ±."
    elif language == 'ru':
        success_text = f"‚úÖ TON –∫–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n**–ê–¥—Ä–µ—Å:** `{wallet_address}`\n\nüì∫ –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å —Å–≤–æ–π –∫–∞–Ω–∞–ª –∏ –ø–æ–ª—É—á–∞—Ç—å –¥–æ—Ö–æ–¥—ã –æ—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏."
    else:
        success_text = f"‚úÖ TON wallet saved successfully!\n\n**Address:** `{wallet_address}`\n\nüì∫ You can now add your channel and receive publishing earnings."
    
    # Handle both Message and CallbackQuery objects
    if hasattr(message_or_callback, 'message'):
        # CallbackQuery
        await message_or_callback.message.answer(success_text, parse_mode='Markdown')
    else:
        # Message
        await message_or_callback.reply(success_text, parse_mode='Markdown')

@router.callback_query(F.data == "cancel_wallet_input")
async def cancel_wallet_input_handler(callback_query: CallbackQuery, state: FSMContext):
    """Handle wallet input cancellation"""
    user_id = callback_query.from_user.id
    language = await get_user_language(user_id)
    
    # Clear wallet-related state
    await state.clear()
    
    # Send cancellation message
    if language == 'ar':
        cancel_text = "‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇÿßŸã."
    elif language == 'ru':
        cancel_text = "‚ùå –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ –∫–æ—à–µ–ª—å–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ."
    else:
        cancel_text = "‚ùå Wallet address input cancelled. You can try again later."
    
    await callback_query.message.edit_text(cancel_text)
    await callback_query.answer()