"""
TON Wallet Address Management System
Handles wallet address collection and storage for different scenarios
"""

import asyncio
import logging
from typing import Optional, Dict, Any
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from states import WalletStates, AdCreationStates, CreateAd
from database import db
from languages import get_text
from database import get_user_language


logger = logging.getLogger(__name__)
router = Router()

class WalletManager:
    """Centralized TON wallet address management"""
    
    @staticmethod
    def validate_ton_address(address: str) -> bool:
        """Validate TON wallet address format"""
        if not address:
            return False
        
        # Remove whitespace
        address = address.strip()
        
        # Check prefix and length
        if not (address.startswith('EQ') or address.startswith('UQ')):
            return False
        
        if len(address) != 48:
            return False
        
        # Check if it's alphanumeric + allowed characters
        allowed_chars = set('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_')
        if not all(c in allowed_chars for c in address):
            return False
        
        return True
    
    @staticmethod
    async def get_user_wallet_address(user_id: int) -> Optional[str]:
        """Get user's stored TON wallet address"""
        try:
            user = await db.get_user(user_id)
            if user:
                return user.get('ton_wallet_address')
            return None
        except Exception as e:
            logger.error(f"Error getting user wallet address: {e}")
            return None
    
    @staticmethod
    async def set_user_wallet_address(user_id: int, wallet_address: str) -> bool:
        """Store user's TON wallet address"""
        try:
            await db.set_user_wallet_address(user_id, wallet_address)
            return True
        except Exception as e:
            logger.error(f"Error setting user wallet address: {e}")
            return False
    
    @staticmethod
    async def request_wallet_address(message_or_callback, state: FSMContext, context: str = 'payment'):
        """Request TON wallet address from user based on context"""
        # Handle both Message and CallbackQuery types
        if hasattr(message_or_callback, 'from_user'):
            user_id = message_or_callback.from_user.id
            if hasattr(message_or_callback, 'message'):
                # CallbackQuery
                send_method = message_or_callback.message.edit_text
            else:
                # Message
                send_method = message_or_callback.reply
        else:
            return
        
        language = await get_user_language(user_id)
        
        # Check if user already has a wallet address
        existing_wallet = await WalletManager.get_user_wallet_address(user_id)
        
        if existing_wallet:
            # User has existing wallet, ask if they want to use it or enter new one
            await WalletManager.show_wallet_options(message_or_callback, state, existing_wallet, context)
            return
        
        # No existing wallet, request new one
        await WalletManager.show_wallet_input_prompt(message_or_callback, state, context)
    
    @staticmethod
    async def show_wallet_options(message_or_callback, state: FSMContext, existing_wallet: str, context: str):
        """Show options to use existing wallet or enter new one"""
        user_id = message_or_callback.from_user.id
        language = await get_user_language(user_id)
        
        # Create context-specific messages
        if context == 'payment':
            if language == 'ar':
                title = "üí∞ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿØŸÅÿπ"
                description = "ŸÑÿØŸäŸÉ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`{wallet_display}`"
                enter_new = "üîÑ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≠ŸÅÿ∏ÿ© ÿ¨ÿØŸäÿØÿ©"
            elif language == 'ru':
                title = "üí∞ TON –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã"
                description = "–£ –≤–∞—Å –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π TON –∫–æ—à–µ–ª–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫\n`{wallet_display}`"
                enter_new = "üîÑ –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫"
            else:
                title = "üí∞ TON Wallet Address for Payment"
                description = "You have a saved TON wallet. Choose an option:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ Use Current Wallet\n`{wallet_display}`"
                enter_new = "üîÑ Enter New Wallet"
        
        elif context == 'affiliate':
            if language == 'ar':
                title = "ü§ù ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπ"
                description = "ŸÑÿØŸäŸÉ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`{wallet_display}`"
                enter_new = "üîÑ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≠ŸÅÿ∏ÿ© ÿ¨ÿØŸäÿØÿ©"
            elif language == 'ru':
                title = "ü§ù TON –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã"
                description = "–£ –≤–∞—Å –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π TON –∫–æ—à–µ–ª–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫\n`{wallet_display}`"
                enter_new = "üîÑ –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫"
            else:
                title = "ü§ù TON Wallet Address for Affiliate Program"
                description = "You have a saved TON wallet. Choose an option:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ Use Current Wallet\n`{wallet_display}`"
                enter_new = "üîÑ Enter New Wallet"
        
        elif context == 'channel':
            if language == 'ar':
                title = "üì∫ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ©"
                description = "ŸÑÿØŸäŸÉ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÖÿ≥ÿ®ŸÇÿßŸã. ÿßÿÆÿ™ÿ± ÿÆŸäÿßÿ±:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©\n`{wallet_display}`"
                enter_new = "üîÑ ÿ•ÿØÿÆÿßŸÑ ŸÖÿ≠ŸÅÿ∏ÿ© ÿ¨ÿØŸäÿØÿ©"
            elif language == 'ru':
                title = "üì∫ TON –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞"
                description = "–£ –≤–∞—Å –µ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π TON –∫–æ—à–µ–ª–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–æ—à–µ–ª–µ–∫\n`{wallet_display}`"
                enter_new = "üîÑ –í–≤–µ—Å—Ç–∏ –Ω–æ–≤—ã–π –∫–æ—à–µ–ª–µ–∫"
            else:
                title = "üì∫ TON Wallet Address for Channel Addition"
                description = "You have a saved TON wallet. Choose an option:"
                # Format wallet address properly
                wallet_display = existing_wallet[:10] + '...' + existing_wallet[-8:] if len(existing_wallet) > 20 else existing_wallet
                use_existing = f"‚úÖ Use Current Wallet\n`{wallet_display}`"
                enter_new = "üîÑ Enter New Wallet"
        
        text = f"**{title}**\n\n{description}"
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=use_existing, callback_data=f"use_existing_wallet_{context}")],
            [InlineKeyboardButton(text=enter_new, callback_data=f"enter_new_wallet_{context}")],
            [InlineKeyboardButton(text="‚ùå Cancel" if language == 'en' else "‚ùå ÿ•ŸÑÿ∫ÿßÿ°" if language == 'ar' else "‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_wallet_input")]
        ])
        
        # Store context and existing wallet for later use - PRESERVE existing state data
        current_data = await state.get_data()
        await state.update_data(
            wallet_context=context,
            existing_wallet=existing_wallet,
            # Preserve payment data if it exists
            **{k: v for k, v in current_data.items() if k.startswith(('pending_payment', 'payment_', 'amount_', 'final_pricing'))}
        )
        
        if hasattr(message_or_callback, 'message'):
            await message_or_callback.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        else:
            await message_or_callback.reply(text, reply_markup=keyboard, parse_mode='Markdown')
    
    @staticmethod
    async def show_wallet_input_prompt(message_or_callback, state: FSMContext, context: str):
        """Show wallet input prompt based on context"""
        user_id = message_or_callback.from_user.id
        language = await get_user_language(user_id)
        
        # Create context-specific messages
        if context == 'payment':
            if language == 'ar':
                title = "üí∞ ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿØŸÅÿπ"
                description = "ŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿØŸÅÿπÿ© TONÿå ŸÜÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ:"
                instructions = """**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:**
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ Ÿáÿ∞ÿß ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÑÿ∞Ÿä ÿ≥ÿ™ÿØŸÅÿπ ŸÖŸÜŸá
- Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿ£ŸÖŸàÿßŸÑ"""
            elif language == 'ru':
                title = "üí∞ –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ TON –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã"
                description = "–î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ TON –ø–ª–∞—Ç–µ–∂–∞ –Ω–∞–º –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞:"
                instructions = """**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**
- –≠—Ç–æ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∞–¥—Ä–µ—Å, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã –±—É–¥–µ—Ç–µ –ø–ª–∞—Ç–∏—Ç—å
- –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å EQ –∏–ª–∏ UQ
- –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ—á–Ω–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
- –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ—Ç–µ—Ä–∏ —Å—Ä–µ–¥—Å—Ç–≤"""
            else:
                title = "üí∞ Enter TON Wallet Address for Payment"
                description = "To process your TON payment, we need your wallet address:"
                instructions = """**Instructions:**
- This should be the address you will pay from
- Starts with EQ or UQ
- Must be exactly 48 characters
- Ensure the address is correct to avoid loss of funds"""
        
        elif context == 'affiliate':
            if language == 'ar':
                title = "ü§ù ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπ"
                description = "ŸÑÿ™ŸÑŸÇŸä ÿπŸÖŸàŸÑÿßÿ™ ÿßŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπÿå ŸÜÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ:"
                instructions = """**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:**
- ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÖŸàŸÑÿßÿ™ ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿπŸÜŸàÿßŸÜ
- Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿπŸÖŸàŸÑÿßÿ™"""
            elif language == 'ru':
                title = "ü§ù –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ TON –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã"
                description = "–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–∏—Å—Å–∏–π –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞–º –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞:"
                instructions = """**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**
- –í—Å–µ –∫–æ–º–∏—Å—Å–∏–∏ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ —ç—Ç–æ—Ç –∞–¥—Ä–µ—Å
- –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å EQ –∏–ª–∏ UQ
- –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ—á–Ω–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
- –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –∫–æ–º–∏—Å—Å–∏–∏"""
            else:
                title = "ü§ù Enter TON Wallet Address for Affiliate Program"
                description = "To receive affiliate commissions, we need your wallet address:"
                instructions = """**Instructions:**
- All commissions will be sent to this address
- Starts with EQ or UQ
- Must be exactly 48 characters
- Ensure the address is correct to avoid losing commissions"""
        
        elif context == 'channel':
            if language == 'ar':
                title = "üì∫ ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ© TON ŸÑÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ©"
                description = "ŸÑÿ™ŸÑŸÇŸä ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©ÿå ŸÜÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ÿπŸÜŸàÿßŸÜ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ:"
                instructions = """**ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:**
- ÿ≥Ÿäÿ™ŸÖ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ¨ŸÖŸäÿπ ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÜÿ¥ÿ± ÿ•ŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿπŸÜŸàÿßŸÜ
- Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ
- Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿπŸÜŸàÿßŸÜ ŸÑÿ™ÿ¨ŸÜÿ® ŸÅŸÇÿØÿßŸÜ ÿßŸÑÿ£ÿ±ÿ®ÿßÿ≠"""
            elif language == 'ru':
                title = "üì∫ –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ TON –∫–æ—à–µ–ª—å–∫–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞"
                description = "–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Ö–æ–¥–æ–≤ –æ—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –≤ –∫–∞–Ω–∞–ª–µ –Ω–∞–º –Ω—É–∂–µ–Ω –∞–¥—Ä–µ—Å –≤–∞—à–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞:"
                instructions = """**–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:**
- –í—Å–µ –¥–æ—Ö–æ–¥—ã –æ—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –±—É–¥—É—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ —ç—Ç–æ—Ç –∞–¥—Ä–µ—Å
- –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å EQ –∏–ª–∏ UQ
- –î–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ç–æ—á–Ω–æ 48 —Å–∏–º–≤–æ–ª–æ–≤
- –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ç–µ—Ä—è—Ç—å –¥–æ—Ö–æ–¥—ã"""
            else:
                title = "üì∫ Enter TON Wallet Address for Channel Addition"
                description = "To receive channel publishing earnings, we need your wallet address:"
                instructions = """**Instructions:**
- All publishing earnings will be sent to this address
- Starts with EQ or UQ
- Must be exactly 48 characters
- Ensure the address is correct to avoid losing earnings"""
        
        text = f"**{title}**\n\n{description}\n\n{instructions}\n\n**Example:** `EQDZpONCwPqBcWezyEGK9ikCHMknoyTrBL-L2hATQbClmrSE`\n\nüí¨ Send your wallet address now:"
        
        keyboard = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚ùå Cancel" if language == 'en' else "‚ùå ÿ•ŸÑÿ∫ÿßÿ°" if language == 'ar' else "‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_wallet_input")]
        ])
        
        # Set appropriate state based on context
        if context == 'payment':
            await state.set_state(WalletStates.payment_wallet_input)
        elif context == 'affiliate':
            await state.set_state(WalletStates.affiliate_wallet_input)
        elif context == 'channel':
            await state.set_state(WalletStates.channel_wallet_input)
        
        # Store context for later use - PRESERVE existing state data
        current_data = await state.get_data()
        await state.update_data(
            wallet_context=context,
            # Preserve payment data if it exists
            **{k: v for k, v in current_data.items() if k.startswith(('pending_payment', 'payment_', 'amount_', 'final_pricing'))}
        )
        
        if hasattr(message_or_callback, 'message'):
            await message_or_callback.message.edit_text(text, reply_markup=keyboard, parse_mode='Markdown')
        else:
            await message_or_callback.reply(text, reply_markup=keyboard, parse_mode='Markdown')

# Callback handlers for wallet options
@router.callback_query(F.data.startswith("use_existing_wallet_"))
async def use_existing_wallet_handler(callback_query: CallbackQuery, state: FSMContext):
    """Handle using existing wallet address"""
    try:
        user_id = callback_query.from_user.id
        language = await get_user_language(user_id)
        
        # Extract context from callback data
        context = callback_query.data.replace("use_existing_wallet_", "")
        
        # Get existing wallet from state data
        data = await state.get_data()
        existing_wallet = data.get('existing_wallet')
        
        # If no wallet in state, try to get from database
        if not existing_wallet:
            existing_wallet = await WalletManager.get_user_wallet_address(user_id)
        
        if not existing_wallet:
            # Show error message in user's language
            error_msg = {
                'ar': "‚ùå ÿÆÿ∑ÿ£: ŸÑÿß ŸäŸàÿ¨ÿØ ŸÖÿ≠ŸÅÿ∏ÿ© ŸÖÿ≠ŸÅŸàÿ∏ÿ©",
                'ru': "‚ùå –û—à–∏–±–∫–∞: –ù–µ –Ω–∞–π–¥–µ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π –∫–æ—à–µ–ª–µ–∫",
                'en': "‚ùå Error: No saved wallet found"
            }.get(language, "‚ùå Error: No saved wallet found")
            
            await callback_query.answer(error_msg, show_alert=True)
            return
        
        # Show loading message
        loading_msg = {
            'ar': "üîÑ ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿ™ÿßÿ®ÿπÿ© ÿ®ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©...",
            'ru': "üîÑ –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å —Ç–µ–∫—É—â–∏–º –∫–æ—à–µ–ª—å–∫–æ–º...",
            'en': "üîÑ Continuing with current wallet..."
        }.get(language, "üîÑ Continuing with current wallet...")
        
        await callback_query.answer(loading_msg)
        
        # Continue with the appropriate flow based on context
        if context == 'payment':
            await continue_payment_with_wallet(callback_query, state, existing_wallet)
        elif context == 'affiliate':
            await continue_affiliate_with_wallet(callback_query, state, existing_wallet)
        elif context == 'channel':
            await continue_channel_with_wallet(callback_query, state, existing_wallet)
        else:
            # Unknown context error
            error_msg = {
                'ar': "‚ùå ÿÆÿ∑ÿ£: ÿ≥ŸäÿßŸÇ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ",
                'ru': "‚ùå –û—à–∏–±–∫–∞: –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç",
                'en': "‚ùå Error: Unknown context"
            }.get(language, "‚ùå Error: Unknown context")
            
            await callback_query.answer(error_msg, show_alert=True)
            
    except Exception as e:
        logger.error(f"Error in use_existing_wallet_handler: {e}")
        
        # Show generic error message
        error_msg = {
            'ar': "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ",
            'ru': "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑",
            'en': "‚ùå An error occurred, please try again"
        }.get(language, "‚ùå An error occurred, please try again")
        
        await callback_query.answer(error_msg, show_alert=True)

@router.callback_query(F.data.startswith("enter_new_wallet_"))
async def enter_new_wallet_handler(callback_query: CallbackQuery, state: FSMContext):
    """Handle entering new wallet address"""
    context = callback_query.data.replace("enter_new_wallet_", "")
    
    # Show wallet input prompt
    await WalletManager.show_wallet_input_prompt(callback_query, state, context)
    await callback_query.answer()

# Message handlers for wallet address input
@router.message(WalletStates.payment_wallet_input)
async def handle_payment_wallet_input(message: Message, state: FSMContext):
    """Handle wallet address input for payment"""
    await process_wallet_input(message, state, 'payment')

@router.message(WalletStates.affiliate_wallet_input)
async def handle_affiliate_wallet_input(message: Message, state: FSMContext):
    """Handle wallet address input for affiliate program"""
    await process_wallet_input(message, state, 'affiliate')

@router.message(WalletStates.channel_wallet_input)
async def handle_channel_wallet_input(message: Message, state: FSMContext):
    """Handle wallet address input for channel addition"""
    await process_wallet_input(message, state, 'channel')

async def process_wallet_input(message: Message, state: FSMContext, context: str):
    """Process wallet address input"""
    user_id = message.from_user.id
    language = await get_user_language(user_id)
    wallet_address = message.text.strip()
    
    # Validate wallet address
    if not WalletManager.validate_ton_address(wallet_address):
        if language == 'ar':
            error_text = "‚ùå ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠. Ÿäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ®ÿØÿ£ ÿ®ŸÄ EQ ÿ£Ÿà UQ ŸàŸäŸÉŸàŸÜ 48 ÿ≠ÿ±ŸÅÿßŸã. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ:"
        elif language == 'ru':
            error_text = "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∞–¥—Ä–µ—Å –∫–æ—à–µ–ª—å–∫–∞. –î–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å EQ –∏–ª–∏ UQ –∏ –±—ã—Ç—å –¥–ª–∏–Ω–æ–π 48 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:"
        else:
            error_text = "‚ùå Invalid wallet address. Must start with EQ or UQ and be 48 characters long. Try again:"
        
        await message.reply(error_text)
        return
    
    # Store wallet address
    wallet_saved = await WalletManager.set_user_wallet_address(user_id, wallet_address)
    logger.info(f"üíæ Wallet address storage result for user {user_id}: {wallet_saved}")
    
    # Verify the wallet was saved
    try:
        saved_wallet = await WalletManager.get_user_wallet_address(user_id)
        logger.info(f"‚úÖ Verified saved wallet for user {user_id}: {saved_wallet[:10]}...{saved_wallet[-8:] if saved_wallet else 'None'}")
    except Exception as e:
        logger.error(f"‚ùå Error verifying wallet save: {e}")
    
    # Continue with appropriate flow based on context
    if context == 'payment':
        await continue_payment_with_wallet(message, state, wallet_address)
    elif context == 'affiliate':
        await continue_affiliate_with_wallet(message, state, wallet_address)
    elif context == 'channel':
        await continue_channel_with_wallet(message, state, wallet_address)

async def continue_payment_with_wallet(message_or_callback, state: FSMContext, wallet_address: str):
    """Continue payment process with wallet address"""
    # Get payment amount from state - try multiple keys with extensive debugging
    data = await state.get_data()
    logger.info(f"üîç Available state data keys: {list(data.keys())}")
    
    # Try all possible payment amount keys
    amount_ton = (data.get('pending_payment_amount') or 
                  data.get('payment_amount') or 
                  data.get('amount_ton'))
    
    # Try to get from pricing data if not found
    if not amount_ton:
        pricing = data.get('final_pricing', {})
        if pricing and 'ton_amount' in pricing:
            amount_ton = pricing['ton_amount']
            logger.info(f"‚úÖ Found amount in pricing data: {amount_ton} TON")
    
    # If still not found, try to calculate from pricing
    if not amount_ton and 'final_pricing' in data:
        pricing = data['final_pricing']
        if 'final_price' in pricing:
            # Convert USD to TON (approximately 1 USD = 0.36 TON)
            amount_ton = pricing['final_price'] * 0.36
            logger.info(f"‚úÖ Calculated amount from USD price: {amount_ton} TON")
    
    if not amount_ton:
        # Log all available data for debugging
        logger.error(f"‚ùå No payment amount found in state data: {data}")
        
        # Handle both Message and CallbackQuery objects
        error_msg = "‚ùå Payment session expired. Please start over."
        if hasattr(message_or_callback, 'message'):
            # CallbackQuery
            await message_or_callback.message.answer(error_msg)
        else:
            # Message
            await message_or_callback.reply(error_msg)
        return
    
    logger.info(f"‚úÖ Using payment amount: {amount_ton} TON")
    
    # Store wallet address in state
    await state.update_data(user_wallet_address=wallet_address)
    
    # Create a simplified payment processing directly here to avoid complex object handling
    user_id = message_or_callback.from_user.id
    language = await get_user_language(user_id)
    
    # Generate payment details
    import random
    import string
    import time
    from config import TON_WALLET_ADDRESS
    
    bot_wallet = TON_WALLET_ADDRESS or "EQDZpONCwPqBcWezyEGK9ikCHMknoyTrBL-L2hATQbClmrSE"
    
    # Generate unique memo (2 letters + 4 digits format)
    letters = ''.join(random.choices(string.ascii_uppercase, k=2))
    digits = ''.join(random.choices(string.digits, k=4))
    memo = letters + digits
    
    # Create expiration timestamp (20 minutes from now)
    expiration_time = int(time.time()) + (20 * 60)
    
    # Store payment info
    await state.update_data(
        payment_memo=memo,
        payment_amount=amount_ton,
        payment_expiration=expiration_time,
        bot_wallet=bot_wallet
    )
    
    # Create concise payment message to avoid MESSAGE_TOO_LONG
    if language == 'ar':
        payment_text = f"""üí∞ **ÿØŸÅÿπ TON**

**ÿßŸÑŸÖÿ®ŸÑÿ∫:** {amount_ton:.3f} TON
**ÿßŸÑÿπŸÜŸàÿßŸÜ:** `{bot_wallet}`
**ÿßŸÑŸÖÿ∞ŸÉÿ±ÿ©:** `{memo}`

**ÿÆÿ∑Ÿàÿßÿ™ ÿßŸÑÿØŸÅÿπ:**
1. ÿßŸÅÿ™ÿ≠ ŸÖÿ≠ŸÅÿ∏ÿ© TON
2. ÿ£ÿ±ÿ≥ŸÑ {amount_ton:.3f} TON ŸÑŸÑÿπŸÜŸàÿßŸÜ ÿ£ÿπŸÑÿßŸá
3. ÿ£ÿ∂ŸÅ ÿßŸÑŸÖÿ∞ŸÉÿ±ÿ© `{memo}` ÿ®ÿßŸÑÿ∂ÿ®ÿ∑
4. ÿ£ŸÉÿØ ÿßŸÑŸÖÿπÿßŸÖŸÑÿ©

‚è∞ ŸäŸÜÿ™ŸáŸä ŸÅŸä: 20 ÿØŸÇŸäŸÇÿ©
‚úÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÉŸÑ 30 ÿ´ÿßŸÜŸäÿ©"""
    elif language == 'ru':
        payment_text = f"""üí∞ **–û–ø–ª–∞—Ç–∞ TON**

**–°—É–º–º–∞:** {amount_ton:.3f} TON
**–ê–¥—Ä–µ—Å:** `{bot_wallet}`
**–ó–∞–º–µ—Ç–∫–∞:** `{memo}`

**–®–∞–≥–∏ –æ–ø–ª–∞—Ç—ã:**
1. –û—Ç–∫—Ä–æ–π—Ç–µ –≤–∞—à TON –∫–æ—à–µ–ª–µ–∫
2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ {amount_ton:.3f} TON –Ω–∞ –∞–¥—Ä–µ—Å –≤—ã—à–µ
3. –î–æ–±–∞–≤—å—Ç–µ –∑–∞–º–µ—Ç–∫—É `{memo}` —Ç–æ—á–Ω–æ
4. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é

‚è∞ –ò—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑: 20 –º–∏–Ω—É—Ç
‚úÖ –ê–≤—Ç–æ–ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥"""
    else:
        payment_text = f"""üí∞ **TON Payment**

**Amount:** {amount_ton:.3f} TON
**Address:** `{bot_wallet}`
**Memo:** `{memo}`

**Payment Steps:**
1. Open your TON wallet
2. Send {amount_ton:.3f} TON to address above
3. Add memo `{memo}` exactly
4. Confirm transaction

‚è∞ Expires in: 20 minutes
‚úÖ Auto-verification every 30 seconds"""
    
    # Create keyboard with cancel option
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚ùå Cancel Payment", callback_data="cancel_payment")]
    ])
    
    # Send payment message
    if hasattr(message_or_callback, 'message'):
        # CallbackQuery
        await message_or_callback.message.edit_text(payment_text, reply_markup=keyboard, parse_mode='Markdown')
    else:
        # Message
        await message_or_callback.reply(payment_text, reply_markup=keyboard, parse_mode='Markdown')
    
    # Track payment for automatic confirmation
    from automatic_payment_confirmation import track_payment_for_user
    
    # Check if this is a post package purchase
    is_post_package = data.get('post_package_purchase', False)
    
    if is_post_package:
        # Track post package purchase
        calculation = data.get('total_calculation', {})
        package_info = calculation.get('package', {})
        
        ad_data = {
            'type': 'post_package',
            'package_name': package_info.get('name', 'Post Package'),
            'posts_total': package_info.get('posts', 0),
            'auto_schedule_days': data.get('auto_schedule_days', 0),
            'selected_addons': data.get('selected_addons', []),
            'total_usd': calculation.get('total_usd', 0)
        }
        
        logger.info(f"üì¶ Tracking post package purchase: {ad_data}")
    else:
        # Regular campaign payment
        ad_data = {
            'duration_days': data.get('duration_days', 7),
            'posts_per_day': data.get('posts_per_day', 1),
            'selected_channels': data.get('selected_channels', []),
            'total_reach': data.get('total_reach', 0),
            'ad_content': data.get('ad_content', '')
        }
        
        logger.info(f"üì¢ Tracking campaign payment: {ad_data}")
    
    # Track payment for automatic confirmation
    await track_payment_for_user(user_id, memo, amount_ton, ad_data)
    
    # Start payment monitoring using enhanced TON payment monitoring
    import asyncio
    from enhanced_ton_payment_monitoring import monitor_ton_payment_enhanced
    
    # Log the payment initiation
    logger.info(f"üí∞ Starting payment monitoring for user {user_id}: {amount_ton:.3f} TON, memo: {memo}")
    
    # Start monitoring in background
    asyncio.create_task(monitor_ton_payment_enhanced(user_id, memo, amount_ton, expiration_time, wallet_address, state, bot_wallet))
    
    # Set state to wait for payment
    await state.set_state(CreateAd.waiting_payment_confirmation)

async def continue_affiliate_with_wallet(message_or_callback, state: FSMContext, wallet_address: str):
    """Continue affiliate program enrollment with wallet address"""
    user_id = message_or_callback.from_user.id
    language = await get_user_language(user_id)
    
    # Store wallet address for affiliate program
    await state.update_data(affiliate_wallet_address=wallet_address)
    
    # Continue with affiliate enrollment
    if language == 'ar':
        success_text = f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ŸÖÿ≠ŸÅÿ∏ÿ© TON ÿ®ŸÜÿ¨ÿßÿ≠!\n\n**ÿßŸÑÿπŸÜŸàÿßŸÜ:** `{wallet_address}`\n\nü§ù ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ÿßŸÑÿ®ÿ±ŸÜÿßŸÖÿ¨ ÿßŸÑÿ™ÿßÿ®ÿπ Ÿàÿ™ŸÑŸÇŸä ÿßŸÑÿπŸÖŸàŸÑÿßÿ™."
    elif language == 'ru':
        success_text = f"‚úÖ TON –∫–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n**–ê–¥—Ä–µ—Å:** `{wallet_address}`\n\nü§ù –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ø–∞—Ä—Ç–Ω–µ—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ –∏ –ø–æ–ª—É—á–∞—Ç—å –∫–æ–º–∏—Å—Å–∏–∏."
    else:
        success_text = f"‚úÖ TON wallet saved successfully!\n\n**Address:** `{wallet_address}`\n\nü§ù You can now join the affiliate program and receive commissions."
    
    # Handle both Message and CallbackQuery objects
    if hasattr(message_or_callback, 'message'):
        # CallbackQuery
        await message_or_callback.message.answer(success_text, parse_mode='Markdown')
    else:
        # Message
        await message_or_callback.reply(success_text, parse_mode='Markdown')

async def continue_channel_with_wallet(message_or_callback, state: FSMContext, wallet_address: str):
    """Continue channel addition with wallet address"""
    user_id = message_or_callback.from_user.id
    language = await get_user_language(user_id)
    
    # Store wallet address for channel earnings
    await state.update_data(channel_wallet_address=wallet_address)
    
    # Continue with channel addition
    if language == 'ar':
        success_text = f"‚úÖ ÿ™ŸÖ ÿ≠ŸÅÿ∏ ŸÖÿ≠ŸÅÿ∏ÿ© TON ÿ®ŸÜÿ¨ÿßÿ≠!\n\n**ÿßŸÑÿπŸÜŸàÿßŸÜ:** `{wallet_address}`\n\nüì∫ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ™ŸÉ Ÿàÿ™ŸÑŸÇŸä ÿ£ÿ±ÿ®ÿßÿ≠ ÿßŸÑŸÜÿ¥ÿ±."
    elif language == 'ru':
        success_text = f"‚úÖ TON –∫–æ—à–µ–ª–µ–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n**–ê–¥—Ä–µ—Å:** `{wallet_address}`\n\nüì∫ –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å —Å–≤–æ–π –∫–∞–Ω–∞–ª –∏ –ø–æ–ª—É—á–∞—Ç—å –¥–æ—Ö–æ–¥—ã –æ—Ç –ø—É–±–ª–∏–∫–∞—Ü–∏–∏."
    else:
        success_text = f"‚úÖ TON wallet saved successfully!\n\n**Address:** `{wallet_address}`\n\nüì∫ You can now add your channel and receive publishing earnings."
    
    # Handle both Message and CallbackQuery objects
    if hasattr(message_or_callback, 'message'):
        # CallbackQuery
        await message_or_callback.message.answer(success_text, parse_mode='Markdown')
    else:
        # Message
        await message_or_callback.reply(success_text, parse_mode='Markdown')

@router.callback_query(F.data == "cancel_wallet_input")
async def cancel_wallet_input_handler(callback_query: CallbackQuery, state: FSMContext):
    """Handle wallet input cancellation"""
    user_id = callback_query.from_user.id
    language = await get_user_language(user_id)
    
    # Clear wallet-related state
    await state.clear()
    
    # Send cancellation message
    if language == 'ar':
        cancel_text = "‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿ•ÿØÿÆÿßŸÑ ÿπŸÜŸàÿßŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇÿßŸã."
    elif language == 'ru':
        cancel_text = "‚ùå –í–≤–æ–¥ –∞–¥—Ä–µ—Å–∞ –∫–æ—à–µ–ª—å–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω. –í—ã –º–æ–∂–µ—Ç–µ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ."
    else:
        cancel_text = "‚ùå Wallet address input cancelled. You can try again later."
    
    await callback_query.message.edit_text(cancel_text)
    await callback_query.answer()