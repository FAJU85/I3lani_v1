#!/usr/bin/env python3
"""
Continuous Payment Scanner
Runs continuously in background to catch missed payments
"""

import asyncio
import logging
from typing import Dict, Set
from enhanced_ton_payment_monitoring import EnhancedTONPaymentMonitor
import time
import json
import os

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ContinuousPaymentScanner:
    """Continuous background payment scanner"""
    
    def __init__(self):
        self.monitor = EnhancedTONPaymentMonitor()
        self.bot_wallet = "UQDZpONCwPqBcWezyEGK9ikCHMknoyTrBL-L2hATQbClmulB"
        self.confirmed_payments: Set[str] = set()
        self.last_scan_time = 0
        self.scan_interval = 30  # seconds
        self.running = False
        self.pending_payments_file = "pending_payments.json"
        
        # Load confirmed payments from file
        self.load_confirmed_payments()
    
    def load_confirmed_payments(self):
        """Load previously confirmed payments to avoid duplicates"""
        try:
            if os.path.exists(self.pending_payments_file):
                with open(self.pending_payments_file, 'r') as f:
                    data = json.load(f)
                    self.confirmed_payments = set(data.get('confirmed_payments', []))
                    logger.info(f"Loaded {len(self.confirmed_payments)} confirmed payments from file")
        except Exception as e:
            logger.error(f"Error loading confirmed payments: {e}")
    
    def save_confirmed_payments(self):
        """Save confirmed payments to file"""
        try:
            data = {
                'confirmed_payments': list(self.confirmed_payments),
                'last_updated': time.time()
            }
            with open(self.pending_payments_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving confirmed payments: {e}")
    
    async def scan_for_payments(self):
        """Scan for unconfirmed payments"""
        try:
            logger.info("üîç Scanning for unconfirmed payments...")
            
            # Get recent transactions
            data = await self.monitor.get_transactions_toncenter(self.bot_wallet, 100)
            
            if not data:
                logger.warning("No transaction data available")
                return
            
            transactions = data.get('result', [])
            new_payments_found = 0
            
            for tx in transactions:
                if not tx.get('in_msg'):
                    continue
                
                memo = self.monitor.extract_memo_from_transaction(tx)
                
                # Check if this looks like a user payment (6-char memo, 0.36 TON)
                if memo and len(memo) == 6:
                    amount = self.monitor.extract_amount_from_transaction(tx)
                    
                    if abs(amount - 0.36) <= 0.1:  # 0.36 TON ¬± 0.1 tolerance
                        # Check if already confirmed
                        if memo not in self.confirmed_payments:
                            sender = self.monitor.extract_sender_from_transaction(tx)
                            timestamp = tx.get('utime', 0)
                            
                            logger.info(f"üéØ Found unconfirmed payment: {memo}")
                            logger.info(f"   Amount: {amount} TON")
                            logger.info(f"   Sender: {sender}")
                            logger.info(f"   Timestamp: {timestamp}")
                            
                            # Attempt to confirm this payment
                            success = await self.confirm_missed_payment(memo, amount, sender, timestamp)
                            
                            if success:
                                self.confirmed_payments.add(memo)
                                new_payments_found += 1
                                logger.info(f"‚úÖ Successfully confirmed payment {memo}")
                            else:
                                logger.warning(f"‚ùå Failed to confirm payment {memo}")
            
            if new_payments_found > 0:
                self.save_confirmed_payments()
                logger.info(f"üéâ Confirmed {new_payments_found} missed payments")
            else:
                logger.info("‚úÖ No new payments found")
                
        except Exception as e:
            logger.error(f"Error in payment scanning: {e}")
    
    async def confirm_missed_payment(self, memo: str, amount: float, sender: str, timestamp: int):
        """Confirm a missed payment"""
        try:
            logger.info(f"üîÑ Confirming missed payment {memo}...")
            
            # Try to find the user who made this payment using memo tracker
            from payment_memo_tracker import memo_tracker
            user_info = await memo_tracker.get_user_by_memo(memo)
            
            if user_info:
                user_id = user_info['user_id']
                logger.info(f"‚úÖ Found user {user_id} for payment {memo}")
                
                # Send confirmation message to user
                success = await self.send_payment_confirmation_to_user(
                    user_id, memo, amount, user_info['ad_data']
                )
                
                if success:
                    # Mark payment as confirmed in database
                    await memo_tracker.confirm_payment(memo)
                    logger.info(f"‚úÖ Payment {memo} confirmed and user {user_id} notified")
                    return True
                else:
                    logger.error(f"‚ùå Failed to send confirmation to user {user_id}")
                    return False
            else:
                # If no user found, create comprehensive fallback notification
                logger.warning(f"‚ö†Ô∏è No user found for memo {memo}, creating fallback notification")
                
                # Send broadcast notification to all recent users or create admin alert
                success = await self.send_fallback_payment_notification(memo, amount, sender, timestamp)
                
                if success:
                    logger.info(f"‚úÖ Payment {memo} fallback notification sent")
                    return True
                else:
                    logger.error(f"‚ùå Failed to send fallback notification for {memo}")
                    return False
                
        except Exception as e:
            logger.error(f"‚ùå Error confirming payment {memo}: {e}")
            return False
            
            if user_id:
                # Create ad entry for confirmed payment
                ad_data = {
                    'user_id': user_id,
                    'memo': memo,
                    'amount': amount,
                    'payment_method': 'TON',
                    'status': 'confirmed',
                    'content': f'Payment {memo} confirmed automatically',
                    'channels': 'auto-detected',
                    'timestamp': timestamp
                }
                
                # Create ad entry
                success = await self.create_ad_from_payment(ad_data)
                
                if success:
                    logger.info(f"‚úÖ Payment {memo} confirmed and ad created for user {user_id}")
                    
                    # Send confirmation message to user
                    await self.send_payment_confirmation(user_id, memo, amount)
                    
                    return True
                else:
                    logger.error(f"Failed to create ad for payment {memo}")
                    return False
            else:
                # If we can't find the user, still mark as confirmed to prevent reprocessing
                logger.warning(f"User not found for payment {memo}, marking as confirmed")
                return True
            
        except Exception as e:
            logger.error(f"Error confirming payment {memo}: {e}")
            return False
    
    async def find_user_by_memo(self, memo: str):
        """Find user ID by payment memo"""
        try:
            # For now, we'll extract user ID from memo pattern if possible
            # In a real implementation, you'd query the database for pending payments
            
            # If memo follows pattern like "PY6480", we can't extract user ID
            # So we'll need to implement database memo tracking
            
            # For now, return None and let the system handle it gracefully
            return None
            
        except Exception as e:
            logger.error(f"Error finding user by memo {memo}: {e}")
            return None
    
    async def create_ad_from_payment(self, ad_data: dict):
        """Create ad entry from payment data"""
        try:
            # Simple ad creation for confirmed payments
            logger.info(f"Creating ad entry for payment {ad_data['memo']}")
            
            # In a real implementation, you'd save this to database
            # For now, just log success
            
            return True
            
        except Exception as e:
            logger.error(f"Error creating ad from payment: {e}")
            return False
    
    async def send_payment_confirmation_to_user(self, user_id: int, memo: str, amount: float, ad_data: dict):
        """Send comprehensive payment confirmation message to user"""
        try:
            from main_bot import bot_instance
            from languages import get_user_language, get_text
            
            if bot_instance:
                # Get user language
                try:
                    language = await get_user_language(user_id)
                except:
                    language = 'en'  # Default to English
                
                # Create comprehensive confirmation message
                if language == 'ar':
                    confirmation_text = f"""‚úÖ ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿØŸÅÿπ!

üí∞ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿ≥ÿ™ŸÑŸÖ: {amount:.3f} TON
üé´ ÿ±ŸÇŸÖ ÿßŸÑŸÖÿπÿßŸÖŸÑÿ©: {memo}

üéâ ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿÆÿ∑ÿ© ÿ•ÿπŸÑÿßŸÜŸÉ ÿ®ŸÜÿ¨ÿßÿ≠!

üìä ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ≠ŸÖŸÑÿ©:
‚Ä¢ ÿßŸÑŸÖÿØÿ©: {ad_data.get('days', 1)} ÿ£ŸäÿßŸÖ
‚Ä¢ ÿπÿØÿØ ÿßŸÑŸÖŸÜÿ¥Ÿàÿ±ÿßÿ™ ŸäŸàŸÖŸäÿßŸã: {ad_data.get('posts_per_day', 1)}
‚Ä¢ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿÆÿ™ÿßÿ±ÿ©: {len(ad_data.get('selected_channels', []))}

üöÄ ÿ≥Ÿäÿ™ŸÖ ŸÜÿ¥ÿ± ÿ•ÿπŸÑÿßŸÜŸÉ ŸÇÿ±Ÿäÿ®ÿßŸã ÿπŸÑŸâ ÿßŸÑŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖÿÆÿ™ÿßÿ±ÿ©.

ÿ¥ŸÉÿ±ÿßŸã ŸÑÿßÿÆÿ™Ÿäÿßÿ±ŸÉ ÿ•ÿπŸÑÿßŸÜŸä!"""
                elif language == 'ru':
                    confirmation_text = f"""‚úÖ –ü–ª–∞—Ç–µ–∂ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!

üí∞ –ü–æ–ª—É—á–µ–Ω–∞ —Å—É–º–º–∞: {amount:.3f} TON
üé´ ID —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {memo}

üéâ –í–∞—à —Ä–µ–∫–ª–∞–º–Ω—ã–π –ø–ª–∞–Ω —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!

üìä –î–µ—Ç–∞–ª–∏ –∫–∞–º–ø–∞–Ω–∏–∏:
‚Ä¢ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {ad_data.get('days', 1)} –¥–Ω–µ–π
‚Ä¢ –ü–æ—Å—Ç–æ–≤ –≤ –¥–µ–Ω—å: {ad_data.get('posts_per_day', 1)}
‚Ä¢ –í—ã–±—Ä–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã: {len(ad_data.get('selected_channels', []))}

üöÄ –í–∞—à–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Å–∫–æ—Ä–æ –±—É–¥–µ—Ç –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ –≤ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–∞—Ö.

–°–ø–∞—Å–∏–±–æ –∑–∞ –≤—ã–±–æ—Ä I3lani!"""
                else:
                    confirmation_text = f"""‚úÖ Payment Confirmed!

üí∞ Amount Received: {amount:.3f} TON
üé´ Transaction ID: {memo}

üéâ Your ad plan has been successfully activated!

üìä Campaign Details:
‚Ä¢ Duration: {ad_data.get('days', 1)} days
‚Ä¢ Posts per day: {ad_data.get('posts_per_day', 1)}
‚Ä¢ Selected channels: {len(ad_data.get('selected_channels', []))}

üöÄ Your advertisement will be published soon across selected channels.

Thank you for choosing I3lani!"""
                
                # Create navigation keyboard
                from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
                
                if language == 'ar':
                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="üè† ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©", callback_data="back_to_main")],
                        [InlineKeyboardButton(text="üìä ÿ•ÿπŸÑÿßŸÜÿßÿ™Ÿä", callback_data="my_ads")]
                    ])
                elif language == 'ru':
                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")],
                        [InlineKeyboardButton(text="üìä –ú–æ–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏—è", callback_data="my_ads")]
                    ])
                else:
                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="üè† Main Menu", callback_data="back_to_main")],
                        [InlineKeyboardButton(text="üìä My Ads", callback_data="my_ads")]
                    ])
                
                await bot_instance.send_message(
                    user_id, 
                    confirmation_text,
                    reply_markup=keyboard,
                    parse_mode='Markdown'
                )
                
                logger.info(f"‚úÖ Comprehensive confirmation message sent to user {user_id}")
                return True
            else:
                logger.error("‚ùå Bot instance not available")
                return False
            
        except Exception as e:
            logger.error(f"‚ùå Error sending confirmation to user {user_id}: {e}")
            return False
    
    async def send_fallback_payment_notification(self, memo: str, amount: float, sender: str, timestamp: int):
        """Send fallback notification for untracked payments"""
        try:
            from main_bot import bot_instance
            
            if bot_instance:
                # Create admin notification for manual review
                admin_message = f"""üö® UNTRACKED PAYMENT DETECTED

üí∞ Amount: {amount} TON
üé´ Memo: {memo}
üë§ Sender: {sender}
üìÖ Timestamp: {timestamp}

This payment was detected on blockchain but no user mapping found.
Manual review required for user notification.

Action needed: Contact user with memo {memo} for confirmation."""
                
                # Try to send to admin (you can add admin user ID here)
                try:
                    # For now, just log the admin notification
                    logger.info(f"üö® ADMIN ALERT: {admin_message}")
                except Exception as admin_error:
                    logger.error(f"Failed to send admin notification: {admin_error}")
                
                # Create public notification in bot logs
                public_message = f"""‚úÖ PAYMENT DETECTED: {memo}

If you made a payment with memo {memo} for {amount} TON, your payment has been received and confirmed.

Your ad campaign will be activated shortly. If you don't receive confirmation within 10 minutes, please contact support with memo {memo}.

Thank you for using I3lani!"""
                
                logger.info(f"üì¢ PUBLIC NOTIFICATION: {public_message}")
                
                # Store untracked payment for admin review
                await self.store_untracked_payment(memo, amount, sender, timestamp)
                
                return True
            else:
                logger.error("‚ùå Bot instance not available for fallback notification")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error sending fallback notification: {e}")
            return False
    
    async def store_untracked_payment(self, memo: str, amount: float, sender: str, timestamp: int):
        """Store untracked payment for admin review"""
        try:
            import sqlite3
            
            conn = sqlite3.connect("bot.db")
            cursor = conn.cursor()
            
            # Create untracked_payments table if it doesn't exist
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS untracked_payments (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    memo TEXT NOT NULL,
                    amount REAL NOT NULL,
                    sender TEXT,
                    timestamp INTEGER,
                    status TEXT DEFAULT 'pending_review',
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
            """)
            
            # Insert untracked payment
            cursor.execute("""
                INSERT INTO untracked_payments (memo, amount, sender, timestamp)
                VALUES (?, ?, ?, ?)
            """, (memo, amount, sender, timestamp))
            
            conn.commit()
            conn.close()
            
            logger.info(f"‚úÖ Stored untracked payment {memo} for admin review")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error storing untracked payment: {e}")
            return False
    
    async def run_continuous_scanner(self):
        """Run the continuous payment scanner"""
        self.running = True
        logger.info("üöÄ Starting continuous payment scanner...")
        
        while self.running:
            try:
                await self.scan_for_payments()
                await asyncio.sleep(self.scan_interval)
                
            except Exception as e:
                logger.error(f"Error in scanner loop: {e}")
                await asyncio.sleep(self.scan_interval)
    
    def stop_scanner(self):
        """Stop the continuous scanner"""
        self.running = False
        logger.info("üõë Stopping continuous payment scanner...")

# Global scanner instance
payment_scanner = ContinuousPaymentScanner()

async def start_continuous_payment_monitoring():
    """Start the continuous payment monitoring system"""
    logger.info("üöÄ Starting continuous payment monitoring...")
    
    # Start the scanner in background
    scanner_task = asyncio.create_task(payment_scanner.run_continuous_scanner())
    
    return scanner_task

async def stop_continuous_payment_monitoring():
    """Stop the continuous payment monitoring system"""
    payment_scanner.stop_scanner()

# Test function
async def test_payment_scanner():
    """Test the payment scanner"""
    print("üß™ Testing Continuous Payment Scanner")
    print("=" * 50)
    
    scanner = ContinuousPaymentScanner()
    
    # Test one scan
    await scanner.scan_for_payments()
    
    print("‚úÖ Payment scanner test completed")

if __name__ == "__main__":
    asyncio.run(test_payment_scanner())